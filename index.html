<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Voice-Controlled Game</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.1/lib/p5.js"></script>
</head>
<body>
  <script>
    let playerSize = 50;
    let score = 0;
    let gameOver = false;
    let enemySpeed = 1;
    let recognition;
    let lastCommand = "";
    let bullets = [];
    let enemies = [];
    let commands = ["up", "down", "left", "right"];

    function setup() {
      createCanvas(600, 600);
      frameRate(30);
      setupVoiceRecognition();
      setInterval(spawnEnemy, 2000);
    }

    function setupVoiceRecognition() {
      recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      recognition.continuous = true;
      recognition.interimResults = true;

      recognition.onresult = (event) => {
        const command = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
        lastCommand = `Last heard: ${command}`;
        
        if (commands.includes(command)) {
          fireBullet(command.toUpperCase());
        }
      };

      recognition.onend = () => {
        if (!gameOver) recognition.start();
      };

      recognition.start();
    }

    function draw() {
      background(0);
      translate(width / 2, height / 2);
      
      if (!gameOver) {
        // Draw player
        fill(255);
        circle(0, 0, playerSize);

        // Update and draw bullets
        for (let bullet of bullets) {
          if (!bullet.spent) bullet.update();
        }

        // Update and draw enemies
        for (let enemy of enemies) {
          enemy.update();
        }

        // Draw score and last command
        drawHUD();
      } else {
        drawGameOver();
      }
    }

    function drawHUD() {
      fill(255);
      textSize(16);
      textAlign(LEFT);
      text(lastCommand, -width / 2 + 10, -height / 2 + 20);
      text(`Score: ${score}`, -width / 2 + 10, -height / 2 + 40);
      
      // Draw command hints
      textAlign(CENTER);
      text("Say 'up'", 0, -height / 2 + 20);
      text("Say 'down'", 0, height / 2 - 20);
      text("Say 'left'", -width / 2 + 60, 0);
      text("Say 'right'", width / 2 - 60, 0);
    }

    function drawGameOver() {
      fill(255);
      textSize(32);
      textAlign(CENTER);
      text('Game Over!', 0, -20);
      textSize(24);
      text(`Final Score: ${score}`, 0, 20);
      text('Click to restart', 0, 60);
    }

    function mousePressed() {
      if (gameOver) {
        resetGame();
      }
    }

    function resetGame() {
      score = 0;
      gameOver = false;
      enemies = [];
      bullets = [];
      enemySpeed = 1;
      recognition.start();
    }

    function fireBullet(direction) {
      bullets.push(new Bullet(direction));
    }

    function spawnEnemy() {
      if (!gameOver) {
        let direction = random(commands).toUpperCase();
        enemies.push(new Enemy(direction, width / 3));
      }
    }

    class Enemy {
      constructor(direction, distance) {
        this.direction = direction;
        this.size = 25;
        this.x = direction === "LEFT" ? -distance : direction === "RIGHT" ? distance : 0;
        this.y = direction === "UP" ? -distance : direction === "DOWN" ? distance : 0;
      }

      update() {
        this.move();
        this.checkCollision();
        this.display();
      }

      move() {
        switch(this.direction) {
          case "UP": this.y += enemySpeed; break;
          case "DOWN": this.y -= enemySpeed; break;
          case "LEFT": this.x += enemySpeed; break;
          case "RIGHT": this.x -= enemySpeed; break;
        }
      }

      checkCollision() {
        if (dist(this.x, this.y, 0, 0) < (playerSize + this.size) / 2) {
          gameOver = true;
          recognition.stop();
        }
      }

      display() {
        fill(100);
        circle(this.x, this.y, this.size);
      }
    }

    class Bullet {
      constructor(direction) {
        this.direction = direction;
        this.size = 8;
        this.speed = 5;
        this.x = 0;
        this.y = 0;
        this.spent = false;
      }

      update() {
        this.move();
        this.checkCollision();
        this.display();
      }

      move() {
        switch(this.direction) {
          case "UP": this.y -= this.speed; break;
          case "DOWN": this.y += this.speed; break;
          case "LEFT": this.x -= this.speed; break;
          case "RIGHT": this.x += this.speed; break;
        }
      }

      checkCollision() {
        for (let enemy of enemies) {
          if (dist(this.x, this.y, enemy.x, enemy.y) < (this.size + enemy.size) / 2) {
            this.spent = true;
            enemies = enemies.filter(e => e !== enemy);
            score++;
            break;
          }
        }
      }

      display() {
        if (!this.spent) {
          fill(255, 0, 0);
          circle(this.x, this.y, this.size);
        }
      }
    }
  </script>
</body>
</html>
